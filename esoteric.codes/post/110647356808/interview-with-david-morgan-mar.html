<!DOCTYPE html>
<html>

<!-- Mirrored from localhost:51503/post/110647356808/interview-with-david-morgan-mar by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Mar 2018 15:50:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interview with David Morgan-Mar</title>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Montserrat" rel="stylesheet">

    
        <link rel="stylesheet" href="../../lib/bootstrap/dist/css/bootstrap.css" />
        <link rel="stylesheet" href="../../css/site.css" />
    
    
</head>
<body>
    <nav class="navbar navbar-fixed-top">
        <img src="../../images/esotericheader.gif" width="128" height="128" class="header-image" />
        <div class="navbar-header">
            <div class="logo-header">
                <a href="../../index.html" class="navbar-brand">ESOTERIC.CODES</a><br />
                <span class="small-header">Platforms, Systems, and Languages that Break from the Norms of Computing</span>
            </div>
        </div>
    </nav>
        

<div id="postContent" class="container body-content">
    <header class="post-header">
        <div class="header-block">
            <h1 class="post-title">
                Interview with David Morgan-Mar

            </h1>
        </div><div class="post-meta"><time datetime="2015-02-10">2015-02-10</time><br></div>
    </header> <!--OO TS--><div class="text post-content">
        <p><i>Very excited to present this interview with David Morgan-Mar. He is responsible for some of the most iconic esolangs, including Piet, Chef, and Whenever, all created in the early 2000’s. Morgan-Mar has a physics background, and is also known for his web comic work, such as Irregular Webcomic!&nbsp;</i></p><p><b>» Do you remember how you first found out about esolangs?</b></p><p>I tried to remember, but honestly I’ve forgotten. It would have been back when I was doing my PhD at university, some time in the 1990s. I had several friends doing computer science, though I was studying physics at the time. It’s likely one of them first showed me some examples of early languages like brainfuck.</p><p><b>» Did you do much programming in other esolangs before creating your own?</b></p><p>Heh, no, none at all. Programming itself I find tedious and painful, and doing it in most esoteric languages would be doubly so. What I like is the creative process of thinking of some new way to approach programming<br>- exploring and breaking paradigms. Once I’ve created the spec for a new language, convinced myself it’s Turing-complete, and written a “Hello World” demo program, that’s about as far as I care to go with it.</p><p><b>»You’ve created languages in a number of different styles: a brainfuck variant with Ook!, at least two languages (Chef and Piet) where the program is encoded in another system (recipes or 2D images), an experimental language with Whenever, and a more philosophical approach with Haifu. I’m wondering which language you created first, if there was a progression from one to the next, based on your own experimentation?</b></p><p>I honestly don’t remember any more, but I think Ook! was probably the first. I remember being intrigued by the idea of esoteric languages, but it took me a while to understand how I could break a paradigm and create something truly original.</p><p>Piet came fairly early on, and is probably the next language I created. I was inspired by Befunge and wondered if I could use an actual image as program code, rather than just a 2D array of characters. Once I realised how I could encode data and instructions in coloured pixels, that paved the way for the rest of the spec.</p><figure><img src="../../../78.media.tumblr.com/e47adb6e8715f69b20480cd7345cd24a/tumblr_inline_njkj6b3RIZ1qaohdj.gif" alt="image"></figure><p>Thomas Schoch, <i>Piet</i></p><p><b>» Any really amazing Piet programs you want to point out? Any programs that really surprised you?</b></p><p>The first one that really surprised me was Thomas Shoch’s “Artistic Hello World”. Up until that point, I’d thought that every Piet program would inevitably end up looking like essentially random blocks of pixels of various sizes, with no really detectable rhyme or reason to it.</p><p>Thomas showed me with that program, plus several others of his - particularly “Piet”, which actually resembles a Piet Mondrain painting - that these programs really could become works of art.</p><p><b>»&nbsp;What is your take on the mix of Piet programs that are more conscious of the aesthetics vs those that are more driven solely by functionality (there seems to be a mix of the two, for example looking at the Piet Program Gallery? How important is the aesthetic value of the images to the idea of Piet?</b></p><p>The original goal I had in mind with Piet was that the programs would not merely be images, but would be able to qualify as graphic art on some level. I never really achieved it myself with my own sample code, but thankfully others have shown it’s possible within the language spec.&nbsp;</p><p>Now, I definitely like to think that Piet programs should endeavour to be aesthetically pleasing - although that’s hard to encapsulate in a language spec!</p><figure><img src="../../../78.media.tumblr.com/a0632af8febba5d2777292b831dcee56/tumblr_inline_njkddkdNJq1qaohdj.png" alt="image"></figure><p>Richard Mitton, <i>Piet Pi</i></p><p><b>»  I wanted to mention the Pi program by Richard Mitton, which stands out&nbsp;to me in how it uses the visual aspect of Piet directly in its process. Any thoughts on that, or are there any other Piet programs that use Piet in a similar way?</b></p><p>This is the next program I saw that blew my mind. (I refrained from mentioning it above only because I saw this question coming…) Just when I thought I’d understood what could be done with Piet, Richard smashed my conceptions again. I think it’s one of the most elegant Piet programs I’ve ever seen. I don’t know of anyone else who’s explicitly used the graphical element of Piet in a similar way, but I’m hoping someone can come up with a new way to do so.</p><p>About the only thing I haven’t seen yet is a Piet program that actually looks like a photo or something when viewed from a distance. I’d bet that it’s achievable. At least, that’s the only thing I can think of that I haven’t seen yet. There’s probably still a few amazing surprises waiting out there.</p><p><b>»&nbsp;It occurred to me that there are two different aesthetics of Piet programs:&nbsp;those that are inspired by the name and create a Mondrian-type look, and then a second aesthetic that’s inspired more from what arises&nbsp;naturally from the language, such as Thomas Schoch’s programs you mentioned earlier. Does that seem accurate, or what is your take on the various looks of Piet programs?</b></p><p>I think that Piet has proven itself a general enough medium now that programmers can achieve virtually any visual appearance they put their mind to. So I don’t like to think of it as constrained to any particular aesthetic - that would be limiting. I’d rather people tried to push the boundaries out and create something we haven’t seen yet.</p><p><b>»Could you tell me how Piet and your other languages were received? Which languages are you most proud of?</b></p><p>Piet is easily my most successful language. There appears to be quite a community out there devoted to it, and I know it’s been used in several computer science courses around the world as an example language.<br></p><p>Naturally this is very fulfilling and makes me proud of my achievement.</p><p>But the language that pleased me the most when I created it is Whenever, which most people seem to have largely overlooked. With Piet, I was really only piercing one paradigm by supposing that programs could be images. With Whenever, I began with the idea of a programming language with no flow control. Personally, I think that’s a much greater leap to make, and it feels like it should seriously restrict what you can achieve. It turns out it does, in that no non-trivial program can ever be guaranteed to terminate, but if you accept that, you can still achieve an awful lot. And then I realised the language didn’t even need variables to hold data! It has no flow control or data storage in the ways conventionally understood, yet it can still compute things. I think that’s pretty impressive, in terms of busting paradigms.</p><p>Is it obvious that breaking paradigms is what I get the most kick out of? :-)</p><p><b>» I’m curious about the role of chance in Whenever. There’s the randomness to when things are executed, but then you offer a way to manage it with the defer statement. Is Whenever intended to make the programmer embrace chance as part of the experience of programming the language, or is that simply a way to get the programmer off of a procedural way of thinking?</b></p><p>Well the randomness does need to be managed in some way, lest the output of a program be totally uncontrollable. But I wanted to push it as far as I could while maintaining just enough control to compute things. The real goal behind the design was to break out of the procedural programming mindset. That led me to new territory, rather than just another obfuscated procedural language, which is why I like it so much.</p><p><i>Note: Mark Chu-Carroll has an excellent introduction to the Whenever language here.</i></p><p><b>» Is there a type of program or algorithm that plays particularly well to Whenever’s behavior?</b></p><p>I don’t have enough experience or sample programs written in Whenever to really answer that question. I presume that programs that need random number generation could be coded without much difficulty without needing to add anything to the language spec, and without actually implementing a pseudo-random generator algorithm.</p><p>
            <b>
                »

                What is the most complex program you’ve seen written for Whenever so far?
            </b>
        </p><p>That would actually be my own Fibonacci number generator example program. Whenever seems to be unpopular enough that nobody sends me any new examples!</p><figure><img src="../../../78.media.tumblr.com/195eeb7b12c5a96641f4b0d5965b79f1/tumblr_inline_njkdz2Yh9K1qaohdj.jpg" alt="image"></figure><p>Mike Worth, <i>Hello World Cake</i></p><p>
            <b>
                »

                What are the recipes like that you end up with when writing a Chef program? Have you tried making any?
            </b>
        </p><p>They’re generally pretty bizarre. I’ve heard of people trying to write Chef programs that also work as real recipes, but so far I haven’t seen a working example. And no, I’m not that masochistic - though if someone manages to make a dual-purpose recipe/program, I might try it.</p><p><i>Note: After searching far and wide, actually found one! The Hello World Cake by Mike Worth.</i></p><p>
            <b>
                »

                You mentioned, as part of building a new language, convincing&nbsp;yourself that a language is Turing Complete. How do you go about doing that? Is that a benchmark for any new language you make (and if so, why)? Are there other benchmarks that are important for a new esolang?
            </b>
        </p><p>That’s a slightly tricky question. Personally, I don’t go through any formal proof. I haven’t done enough computer science training to know exactly what’s required. Rather, I just convince myself informally that the language has the basic requirements, such as conditional branching and data storage. A shortcut is to show that the language can mimic any of the eight operations of Brainfuck, which is a sort of benchmark for minimal Turing completeness.</p><p>
            <b>
                »

                At the time you were heavily involved, where did esolangers communicate? What was the community like then?
            </b>
        </p><p>There were ancient technologies like the Usenet group comp.lang.misc, and the Esoteric Languages Webring, and a mailing list. I don’t remember a lot of interaction myself. I was more interested in coming up with new weird stuff than in discussing and fine-tuning and actually attempting to use these languages to code in.</p><p>
            <b>
                »

                Are you still involved much now? Have any recent esolangs stood out to you in particular?
            </b>
        </p><p>No, I haven’t been involved in esolangs for years now. I don’t know what the latest trends or languages are. I still get people emailing me and asking for clarifications on the specs of languages I wrote years ago - which is nice because it shows people are still interested in them - but usually my answer is something like, “Sorry, I haven’t even thought about that language in over a decade - please interpret the spec in whatever way you think makes the most sense.” Actually trying to get into the required mindset to answer a question on any deeper level than that is just too difficult now.</p><p>
            <b>
                »

                For people curious about esolangs who are less technical, any advice on how to get started?
            </b>
        </p><p>I think a sensible approach would be to experience as many esoteric languages as you can. Get a feel for how different they can be, and what programming paradigms they bend or ignore. Perhaps try coding a few simple programs in a few different languages to understand what can (and can’t) be done. I’d say that breadth of experience is much more important than depth of knowledge about any given language. If all you know is Brainfuck, then it’s easy to create a Brainfuck clone, but not anything more interesting. (My own Ook! is my most embarrassing language.) </p><p>The path to esotericism is an odd one. To quote Yoda, you have to unlearn what you know about programming, and then approach it from a completely different mindset. Think about something that most (or all) programming languages do, and then come up with a language that doesn’t do that. Think about something that no languages do, and then do that.</p><p>If you can achieve both those tasks, you’re on your way.</p>
    </div>


</div>


        <div class="container body-content">
            <hr />
            <footer>
                Supported by
                <img src="../../images/logos/zkm-logo.svg" />
                <img src="../../images/logos/CC_logo_hires.jpg" height="30" width="156" />
                <img src="../../images/logos/aw_logo_credit.jpg" height="50" />
            </footer>
        </div>

        
            <script src="../../lib/jquery/dist/jquery.js"></script>
            <script src="../../lib/bootstrap/dist/js/bootstrap.js"></script>
            <script src="../../js/sitedaa0.js?v=ji3-IxbEzYWjzzLCGkF1KDjrT2jLbbrSYXw-AhMPNIA"></script>
        
        

        
</body>

<!-- Mirrored from localhost:51503/post/110647356808/interview-with-david-morgan-mar by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Mar 2018 15:50:46 GMT -->
</html>
