<!DOCTYPE html>
<html>

<!-- Mirrored from localhost:51503/post/116301246873/conceptual-languages-part-2 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Mar 2018 15:51:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Conceptual Languages, Part 2</title>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Montserrat" rel="stylesheet">

    
        <link rel="stylesheet" href="../../lib/bootstrap/dist/css/bootstrap.css" />
        <link rel="stylesheet" href="../../css/site.css" />
    
    
</head>
<body>
    <nav class="navbar navbar-fixed-top">
        <img src="../../images/esotericheader.gif" width="128" height="128" class="header-image" />
        <div class="navbar-header">
            <div class="logo-header">
                <a href="../../index.html" class="navbar-brand">ESOTERIC.CODES</a><br />
                <span class="small-header">Platforms, Systems, and Languages that Break from the Norms of Computing</span>
            </div>
        </div>
    </nav>
        

<div id="postContent" class="container body-content">
    <header class="post-header">
        <div class="header-block">
            <h1 class="post-title">
                Conceptual Languages (Part 2)

            </h1>
        </div><div class="post-meta"><time datetime="2015-04-13">2015-04-13</time><br></div>
    </header> <!--OO TS--><div class="text post-content">
        <figure data-orig-width="348" data-orig-height="310" class="tmblr-full"><img src="../../../78.media.tumblr.com/a744e1b5fc04dedf842f7036ee704874/tumblr_inline_nmpybxtmAq1qaohdj_400.jpg" alt="image" data-orig-width="348" data-orig-height="310" width="348" height="310"></figure><p>

            In the first post on Conceptual Languages (<a href="../102380982203/unnecessary-purely-conceptual-languages.html">last November</a>), I described a language whose programs have to not exist to be valid, and one where every file is equally a valid program and no specific behavior could be drawn from any one of them. I called these “purely conceptual languages,” an idea that I want to revisit here.
        </p><p>“Conceptual” is a bit of a loaded word.&nbsp;Rather than get specifically into Conceptual Art, the early algorists, etc (although I will touch on this a bit and we will def get deeper into these connections in other posts), I want to define what I mean more simply for the moment. While (almost) no esolangs are practical for writing useful programs, the conceptual languages are essentially ONLY concepts, they are not usable even for the simplest languages we attempt in esoprogramming. The focus is instead on unusual uses of language design and/or interpretation. For example:</p><ol><li>Languages whose rules can never result in a working compiler or interpreter</li><li>Compilers which disregard the source code of the programs, or produce the same program every time</li><li>Languages which are otherwise unprogrammable or uncomputable</li></ol><p>

            Many are joke languages, of varying levels of cleverness; some are self-referential loops that use logic against itself. Here are a few selections, with the simplest to understand at the top:

        </p><figure data-orig-width="450" data-orig-height="346" class="tmblr-full"><img src="../../../78.media.tumblr.com/11798987a476c2892ddaab40269e8659/tumblr_inline_nmr2ffWPbX1qaohdj_500.jpg" alt="image" data-orig-width="450" data-orig-height="346" width="450" height="346"></figure><p><i>One and Three Chairs</i>, Joseph Kosuth</p><p>

            For anyone who needs convincing that absolutely anything can be considered a programming language, there is the language <b>Cheese</b> (2007), which is cheese, or an image of cheese, and a programming language … of cheese. How a language of cheese would function is left as an exercise for the user. Taking the joke further, <b>Cheese+</b> (2011) is a language whose interpreter is written in the language Cheese. To make the challenge of the language more concrete, the wiki page notes that an interpreter for Cheese+ was available through 2012 but no longer is; no further explanation is offered.<br>
        </p><p>
            <b>6ix</b>&nbsp;(2009) provides what seems like an ordinary list of commands, “Goto,” “Print,” “Var,” etc. Except in 6ix, each one of these ultimately produces a “Hello, World!” program. “Hello, World!” is the default program one writes in a new language (a license for the first “Hello, World!” sold recently&nbsp;in an Artsy auction)

            &nbsp;Goto adds a typical “goto” statement, but it always goes to the line that prints “Hello, World!”, Loop creates a single loop, executed a single time, in which “Hello, World!” is printed, etc. A simple joke but clever.<br>
        </p><p>

            The language <b>2014</b>&nbsp;(2014) can take any file as input. If the current year is 2014, it will output a "Hello, World!” program. If 2014 is run in any other year, the program will have no output. The first interpreter for the language was announced on Dec 31, 2014, with only 3.5 hours left for programs to be run. However many were executed before the deadline is unknown; running them now will do nothing, it is forever invalidated. <br>
        </p><p>

            My language <b>A programming language is a formal constructed language designed to communicate instructions to a machine, particularly a computer.</b> (2014) is a language which simply reaffirms that a piece of code is valid within its system, by printing its own source code to the screen. The phrase “A programming language is a formal constructed language designed to communicate instructions to a machine, particularly a computer.” is the unique program for the language: it is the name of the language, the only functional source code, and the output of that program when run. Any other content in the file is ignored.

            <br>
        </p><p>

            While this language obliterates any distinction between language, program, and output, it is also constantly changing. It is the first line of the Wikipedia entry on Programming Languages. Previously the name of the language was “A programming language is an artificial language designed to communicate instructions to a machine, particularly a computer.” While programs written with the old text are no longer valid, according to Google there are still 16,300 of them on the Web, with only half that many correct programs. Running the compiler for this language with a web page where someone has blindly quoted Wikipedia will wipe out the rest of the page, revealing just the single sentence. Programs are (almost) never written intentionally in this language.<br>
        </p><p>

            Getting to more technically complex languages,&nbsp;<b>Quiler</b> (2013), which turns compilation into a pretzel of self-referential logic. Quoting from its esolangs.org entry (which I’m still wrapping my head around):&nbsp;
        </p><blockquote><div>The semantics of Quiler are simple: given any input program, a Quiler compiler ignores it and outputs a Quiler compiler that targets the same language that the original compiler did. As such, all possible input programs are Quiler compilers in Quiler; and all total programs in any language are Quiler compilers that target Quiler. Also, all quines* are Quiler compilers written in, and targeting, the same language (although a Quiler compiler need not be a quine).</div></blockquote><p>* A quine = a program which prints its own source code to the screen</p><p><b>You are Reading the Name of This Esolang</b>&nbsp;(2007) (pronounced “You are Hearing the Name of This Esolang”) is a fascinating language that uses algorithmic undecidability as a language feature. As its creator, Chris Pressey, puts it, this means that “the problem of determining whether or not a given string of symbols is a well-formed You are Reading the Name of this Esolang program is undecidable.” (notes on the language can be downloaded with the compiler from the Cats Eye site)&nbsp;</p><p>How is this done? It is built on Spoon, a Huffman-encoded version of brainfuck (what that gives us: Huffman coding is an easy way to represent something efficiently in 1s and 0s, and brainfuck is one of the smallest languages we can map to in order to guarantee Turing Completeness). In addition to the 1s and 0s are brackets, marking subprograms to be run first, resolving to 1s or 0s: 1s for subprograms which will eventually complete, while 0s are subprograms that will run forever. We can look for known non-halting programs and convert them to 0s, but for others, we are stuck – the halting problem tells us there is no consistent and universal way to figure out if a program will ever halt. To make a subprogram resolve to 0 means writing a program that will never end.</p><p>

            About the name: it is noted that You are Reading the Name of This Esolang should not be abbreviated, initialized, or otherwise messed with. Why so much attention on the name? My theory is that, while traditional programming languages try to remain unobtrusive, to let us see how the code will function as clearly as possible, rather than drawing attention to its actual structure as symbols on a screen, esolangs bring our attention back to the language itself. With a language like You are Reading the Name of This Esolang, the name alone is a constant reminder that we are dealing with something very different, where the language is not something we can easily see through, but a structure to be wrestled with, or a puzzle for us to ponder and consider in its own right.&nbsp;
        </p>
    </div>

</div>
        <div class="container body-content">
            <hr />
            <footer>
                Supported by
                <img src="../../images/logos/zkm-logo.svg" />
                <img src="../../images/logos/CC_logo_hires.jpg" height="30" width="156" />
                <img src="../../images/logos/aw_logo_credit.jpg" height="50" />
            </footer>
        </div>

        
            <script src="../../lib/jquery/dist/jquery.js"></script>
            <script src="../../lib/bootstrap/dist/js/bootstrap.js"></script>
            <script src="../../js/sitedaa0.js?v=ji3-IxbEzYWjzzLCGkF1KDjrT2jLbbrSYXw-AhMPNIA"></script>
        
        

        
</body>

<!-- Mirrored from localhost:51503/post/116301246873/conceptual-languages-part-2 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Mar 2018 15:52:01 GMT -->
</html>
