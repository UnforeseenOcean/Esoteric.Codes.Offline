<!DOCTYPE html>
<html>

<!-- Mirrored from localhost:51503/post/84939008828/interview-with-keymaker by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Mar 2018 15:50:46 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interview with Keymaker</title>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Montserrat" rel="stylesheet">

    
        <link rel="stylesheet" href="../../lib/bootstrap/dist/css/bootstrap.css" />
        <link rel="stylesheet" href="../../css/site.css" />
    
    
</head>
<body>
    <nav class="navbar navbar-fixed-top">
        <img src="../../images/esotericheader.gif" width="128" height="128" class="header-image" />
        <div class="navbar-header">
            <div class="logo-header">
                <a href="../../index.html" class="navbar-brand">ESOTERIC.CODES</a><br />
                <span class="small-header">Platforms, Systems, and Languages that Break from the Norms of Computing</span>
            </div>
        </div>
    </nav>
        

<div id="postContent" class="container body-content">
    <header class="post-header">
        <div class="header-block">
            <h1 class="post-title">
                Interview with Keymaker

            </h1>
        </div><div class="post-meta"><time datetime="2011-01-06">2011-01-06</time><br></div>
    </header> <!--OO TS--><div class="text post-content"> <p><img alt="image" src="../../../78.media.tumblr.com/f2374763f12e0581b9913701f7d81fe1/tumblr_inline_n55zdcnq7r1qaohdj.png"><br><em>The 574 cycles of 010001011011</em></p><p><i>Keymaker<span> created languages such as </span>Clue<span>, </span>Unnecessary<span>, and </span>Wheat<span>. He (Keymaker is anonymous but identifies as male) has also developed a host of programs written in brainfuck – one of the most popular esolangs and inspiration for many esolangers – including a brainfuck interpreter written in brainfuck itself. Keymaker maintains a site devoted to brainfuck at </span>http://www.bf-hacks.org<span> and a site for his own esolangs at </span>http://yiap.nfshost.com<span>.</span></i></p><p><i>As has come out in this interview, Keymaker is self-taught, and shows how sophisticated esolanguages can be designed and built by dedicated non-programmers.</i></p>
    
    <p><strong>&gt;&gt; Do you remember how you first found out about esolangs?</strong></p><p>Somewhere I came across brainfuck shown, I think, as a joke or something obscure toy that no “serious programmer” would/should use for anything. At once I knew I had found something that differed from all the traditional languages that I had no interest for at all. It was the best language I had ever seen.</p><p><strong>&gt;&gt; What drew you to create your own languages?</strong></p><p>Brainfuck, essentially. Before seeing it I had thought that you have to be very intelligent or an able mathematician to create a programming language. I was totally clueless of course. I didn’t know anything about computational science, and what I knew of programming and programming languages I wouldn’t even call knowledge now. But one thing was sure; I didn’t like the ‘normal’ languages I was seeing. I still don’t like languages like PHP or C or Java. But with brainfuck I began to see what computation was all about, and after finding more esolangs and programming in them I started to understand that it’s possible for the everyman to create languages that are not only as powerful as the old giants that everybody is telling you to learn and use but far better looking, far more usable (in certain tasks at least), far cooler. Languages where the programs themselves are visual art.</p><p><strong>&gt;&gt; The thought process behind working in C is very different than that of Java, let alone Prolog or SQL. Some esolangs seem to be almost entirely about shaping a particular thought process for the programmer using them. Is the point-of-view of the language something you consider early on, or does it evolve as you build the language?</strong></p><p>It may change, especially if the design process takes a long time (like usually). At times it’s clearer from the beginning and I maintain it till the end, and in those cases the language tends to become completed in a shorter time.</p><p><strong>&gt;&gt; Perhaps you could explain a bit more about why you don’t like PHP, Java, etc – is it because of what they hide from the programmer? Are there high-level languages which you do like?</strong></p><p>It’s difficult to explain why and even I’m not entirely sure of the reasons! It’d seem like I don’t like they way a program works in them, the way it looks like (Java especially is a nightmare). I don’t like binding, if that’s the correct term, memory with variable names. Mostly I use only one-letter variable names if I write in such languages. I hate giving functions and whatever elements an identifying name. Perhaps I’m too sensitive!</p><p>And then there’s the simple fact that I don’t think those languages are very easy or simple at all. More often than not they tend to make a simple task unnecessarily complex. I’m not sure there can be a programming language that’s not difficult to use to some degree since the tasks the languages are used for are not simple. But there could be something easier-to-use and every time I write something I’m asking myself why can’t they have this or that feature that would make things so much easier. Maybe I should try to make a non-esoteric language myself.</p><p>As for good high-level languages… Perhaps there are some that I’d like but I just haven’t found them. The best I’ve used is Python which I use for writing most of my esolang interpreters. It makes many things uncomplicated even if it has its shortcomings.</p><p><strong>&gt;&gt; Do you work as a programmer? If so, have you ever snuck in production code written in an esolang?</strong></p><p>I’m no programmer, no. If I were I might well do that but more likely my approach to the program and its inner logic would be “esoteric” already and the code be something nobody (including me a day later) could decipher.</p><p><strong>&gt;&gt; Could you talk a bit about your process in language design? Has it been very different between different languages?</strong></p><p>Yes, it has been different for every language but I haven’t always paid as much attention to it as I do nowadays. Generally I’m trying to make much better languages than I’ve done before, although I’ve always tried to make my languages as good as I’ve been able to.</p><p>Well, obviously all things begin with an idea of some sort. It may be an idea of just an unusual command, a gimmick with the control flow, some weirdness with the syntax, anything.</p><p>Most of the time I start then thinking what other features the language needs to be Turing-complete. That’s often a kind of benchmark. I haven’t always tried for it but lately I find it difficult not to. But as said, things go differently with every language. I would say it’s much like any other artistic work, the artist looks at things differently as time goes on and wants to work differently. I guess the same goes for any creative work. Anyway, when I have that one idea, the things I add to it should somehow fit with it. I don’t think I could reason what then goes on in my mind. I imagine it’s much what a painter does when choosing the fitting paints and how they’re placed on the canvas – although I may spend a considerably longer time on it. Often a fitting idea comes out of nowhere and when I’m not actively thinking of the language, I may have forgotten I was planning it in the first place.</p><p><strong>&gt;&gt; What is the design process like for purely conceptual languages like Unnecessary? With that language, there’s no working compiler at all… is it freeing to work in a space where the mechanics of the language are not the focus?</strong></p><p>Unnecessary is the only purely conceptual language I’ve done. It was a quick one to do; I simply got the idea and shaped it all together as I wrote the specs. I guess such a language might be freeing to do every now and then but I haven’t really focused on such languages and Unnecessary was my first language, too, so I did not feel any particular freedom from conventions as I had no previous experience in esolang design.</p><p><strong>&gt;&gt; You mentioned your favorite program type is the quine. Was creating a language where all programs are quines part of the initial idea for Unnecessary?</strong></p><p>Partly. The main idea was that the language could not have programs, other than the kind that don’t exist. (Can it have those then if they don’t exist?) Then I noticed that every valid program (whatever that is) is a/the null-quine but that was more of a by-product of the main idea. Fitting nonetheless!</p><p><strong>&gt;&gt; Clue is fascinating in how it exposes its execution. Was it inspired by Conway’s Game of Life or other cellular automata? Where did the title Come from?</strong></p><p>Technically speaking Clue has no I/O but it’s useful (obviously!) to see what’s going on, and that’s why the interpreter prints out the current program/memory on every cycle. Making this distinction is a bit useless since I’ve never ran a Clue program without viewing the “output” but here it is… And the language was certainly designed with the visual aspects on mind. While I might have been inspired by one-dimensional cellular automata and I had been well exposed to Bitwise Cyclic Tag and a cyclic tag system by making interpreters for them in various esolanguages, I’ve never consciously taken from other things.</p><p>The idea that started Clue was that I thought that what if I made a simple two-instruction system where the data string is both the program and the memory. I wanted every string of 0s and 1s to be a valid program. I tried different instructions but the ones the language ended up using I found the best.</p><p>No idea where the title came from. Mostly a fitting name just appears. I also keep a list of “reserved words” that are waiting for the right languages to be made and attached to them!</p><p><strong>&gt;&gt; How much of a surprise was the look of the Clue images? They remind me of ripple marks in rock.</strong></p><p>It was a huge surprise. I had the feeling I was looking at something natural or organic. The surface of a rock or a seashell. The shape of the programs also made me think of the growth that happens in nature, like the growing of trees; uneven and alternating. Who knows if it exhibits something mechanism that’s found in nature…</p><p><strong>&gt;&gt; How did you learn compiler design? What tools do you use to create languages?</strong></p><p>I’ve actually never made a compiler, unless the word can be used for interpreters also. The answer is, nonetheless, the same: on my own.</p><p>The languages I’ve done haven’t been overtly complex to implement, luckily, and I’ve always been able to imagine the processes the interpreter has to do. And now when I think about it, I’ve also designed esolangs that require more complex interpreters as my interpreter programming skills have bettered. Although their betterment is due my programming in esolangs, paradoxically…</p><p>Most of the design happens in the mind but I tend to use a notepad program to write down the best ideas and run simple executions of designs under work, testing the languages’ powers that way. That’s about it; writing the programs, specifications, and interpreters for a language all happen in the same notepad program.</p><p><strong>&gt;&gt; Any esolangs by other designers you like to program in (apart from brainfuck of course)?</strong></p><p>I have a few favourites; Thue and Underload are big. Then there are many others in which I may program one or two programs and never return to them even if I like the languages. (There’s simply no time for everything.)</p><p><strong>&gt;&gt; Any tips for people starting out in language design?</strong></p><p>Quality over quantity, always. Think hard, don’t start publishing the language before you have thought out all of its features. Don’t have too many features. No more brainfuck variants, there are more than enough! Write a few programs in your language, too, to showcase it and to really see how it works. I guess that’s the best advice I can give. :)</p>  </div>

</div>

        <div class="container body-content">
            <hr />
            <footer>
                Supported by
                <img src="../../images/logos/zkm-logo.svg" />
                <img src="../../images/logos/CC_logo_hires.jpg" height="30" width="156" />
                <img src="../../images/logos/aw_logo_credit.jpg" height="50" />
            </footer>
        </div>

        
            <script src="../../lib/jquery/dist/jquery.js"></script>
            <script src="../../lib/bootstrap/dist/js/bootstrap.js"></script>
            <script src="../../js/sitedaa0.js?v=ji3-IxbEzYWjzzLCGkF1KDjrT2jLbbrSYXw-AhMPNIA"></script>
        
        

        
</body>

<!-- Mirrored from localhost:51503/post/84939008828/interview-with-keymaker by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Mar 2018 15:50:46 GMT -->
</html>
